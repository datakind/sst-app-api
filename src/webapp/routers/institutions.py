"""API functions related to institutions."""

import re

from typing import Annotated, Any, Dict
from fastapi import HTTPException, status, APIRouter, Depends
from pydantic import BaseModel
from sqlalchemy.orm import Session
from sqlalchemy.future import select
from sqlalchemy import and_, delete

from ..utilities import (
    has_access_to_inst_or_err,
    BaseUser,
    AccessType,
    get_external_bucket_name_from_uuid,
    str_to_uuid,
    uuid_to_str,
    get_current_active_user,
    SchemaType,
    PDP_SCHEMA_GROUP,
    UsState,
    get_external_bucket_name,
)

from ..gcsutil import StorageControl
from ..database import (
    get_session,
    InstTable,
    local_session,
)

from ..databricks import DatabricksControl

router = APIRouter(
    tags=["institutions"],
)


class InstitutionCreationRequest(BaseModel):
    """Institution data creation request.

    The UUID is autogenerated by the database.
    """

    # The name should be unique amongst all other institutions.
    name: str | None = None
    state: UsState | None = None
    allowed_schemas: list[SchemaType] | None = None
    # Emails allowed to register under this institution
    allowed_emails: Dict[str, AccessType] | None = None
    # The following is a shortcut to specifying the allowed_schemas list and will mean
    # that the allowed_schemas will be augmented with the PDP_SCHEMA_GROUP.
    is_pdp: bool | None = None
    pdp_id: str | None = None
    retention_days: int | None = None


class Institution(BaseModel):
    """Institution data object."""

    inst_id: str
    name: str
    state: UsState | None = None
    # The following are characteristics of an institution set at institution creation time.
    # If zero, it follows DK defaults (deletion after completion).
    retention_days: int | None = None  # In Days
    pdp_id: str | None = None


@router.get("/institutions", response_model=list[Institution])
def read_all_inst(
    current_user: Annotated[BaseUser, Depends(get_current_active_user)],
    sql_session: Annotated[Session, Depends(get_session)],
) -> Any:
    """Returns overview data on all institutions.

    Only visible to Datakinders.
    """
    if not current_user.is_datakinder():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authorized to read this resource. Select a specific institution.",
        )
    local_session.set(sql_session)
    query_result = local_session.get().execute(select(InstTable))
    res = []
    for elem in query_result:
        res.append(
            {
                "inst_id": uuid_to_str(elem[0].id),
                "name": elem[0].name,
                "state": elem[0].state,
                "retention_days": elem[0].retention_days,
                "pdp_id": None if elem[0].pdp_id is None else elem[0].pdp_id,
            }
        )
    return res


@router.post("/institutions", response_model=Institution)
def create_institution(
    req: InstitutionCreationRequest,
    current_user: Annotated[BaseUser, Depends(get_current_active_user)],
    sql_session: Annotated[Session, Depends(get_session)],
    storage_control: Annotated[StorageControl, Depends(StorageControl)],
    databricks_control: Annotated[DatabricksControl, Depends(DatabricksControl)],
) -> Any:
    """Create a new institution.

    Only available to Datakinders.
    """
    if not current_user.is_datakinder():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authorized to create an institution.",
        )
    if not req.name:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Please set the institution name.",
        )
    if (req.is_pdp and not req.pdp_id) or (req.pdp_id and not req.is_pdp):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Please set the PDP's Institution ID for PDP schools and check PDP as a schema type.",
        )

    pattern = "^[A-Za-z0-9&_ -]*$"
    if not re.match(pattern, req.name):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Only alphanumeric characters, -, _, &, and a space are allowed in institution names.",
        )

    local_session.set(sql_session)
    query_result = (
        local_session.get()
        .execute(
            select(InstTable).where(
                and_(InstTable.name == req.name, InstTable.state == req.state)
            )
        )
        .all()
    )
    if len(query_result) == 0:
        # If the institution does not exist create it and create a storage bucket for it.
        requested_schemas = []
        if req.allowed_schemas:
            requested_schemas = req.allowed_schemas
        if req.is_pdp:
            requested_schemas += PDP_SCHEMA_GROUP
        # if no schema is set and PDP is not set, we default to custom.
        if not requested_schemas:
            requested_schemas = {SchemaType.UNKNOWN}
        local_session.get().add(
            InstTable(
                name=req.name,
                retention_days=req.retention_days,
                pdp_id=req.pdp_id,
                # Sets aren't json serializable, so turn them into lists first
                schemas=list(set(requested_schemas)),
                allowed_emails=req.allowed_emails,
                state=req.state,
                created_by=str_to_uuid(current_user.user_id),
            )
        )
        local_session.get().commit()
        query_result = (
            local_session.get()
            .execute(select(InstTable).where(InstTable.name == req.name))
            .all()
        )
        if not query_result:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Database write of the institution creation failed.",
            )
        if len(query_result) > 1:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Database write of the institution created duplicate entries.",
            )
        # Create a storage bucket for it. During creation, we have to include the /.
        bucket_name = get_external_bucket_name_from_uuid(query_result[0][0].id)
        try:
            storage_control.create_bucket(bucket_name)
        except ValueError as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Storage bucket creation failed:" + str(e),
            ) from e
        try:
            databricks_control.setup_new_inst(query_result[0][0].name)
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Databricks setup failed:" + str(e),
            ) from e
    if len(query_result) > 1:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Institution duplicates found.",
        )
    return {
        "inst_id": uuid_to_str(query_result[0][0].id),
        "name": query_result[0][0].name,
        "state": query_result[0][0].state,
        "pdp_id": query_result[0][0].pdp_id,
        "retention_days": query_result[0][0].retention_days,
    }


@router.patch("/institutions/{inst_id}", response_model=Institution)
def update_inst(
    inst_id: str,
    request: InstitutionCreationRequest,
    current_user: Annotated[BaseUser, Depends(get_current_active_user)],
    sql_session: Annotated[Session, Depends(get_session)],
) -> Any:
    """Modifies an existing institution. Only some fields are allowed to be modified."""
    if not current_user.is_datakinder():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authorized to modify an institution.",
        )

    update_data = request.model_dump(exclude_unset=True)
    local_session.set(sql_session)
    # Check that the batch exists.
    query_result = (
        local_session.get()
        .execute(
            select(InstTable).where(
                InstTable.id == str_to_uuid(inst_id),
            )
        )
        .all()
    )
    if not query_result or len(query_result) != 1:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Unexpected number of institutions found with this id. Expected 1 got "
            + str(len(query_result)),
        )
    existing_inst = query_result[0][0]
    if "name" in update_data:
        if update_data["name"] != existing_inst.name:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Institution names cannot be changed.",
            )
    if (
        "is_pdp" in update_data
        and update_data["is_pdp"]
        and "pdp_id" not in update_data
        and not existing_inst.pdp_id
    ):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="If is_pdp is set, pdp_id must also be set.",
        )

    if "state" in update_data:
        existing_inst.state = update_data["state"]
    if "allowed_schemas" in update_data:
        existing_inst.allowed_schemas = update_data["allowed_schemas"]
    if "allowed_emails" in update_data:
        existing_inst.allowed_emails = update_data["allowed_emails"]
    if "is_pdp" in update_data:
        existing_inst.is_pdp = update_data["is_pdp"]
    if "pdp_id" in update_data:
        existing_inst.pdp_id = update_data["pdp_id"]
    if "retention_days" in update_data:
        existing_inst.retention_days = update_data["retention_days"]

    local_session.get().commit()
    res = (
        local_session.get()
        .execute(
            select(InstTable).where(
                InstTable.id == str_to_uuid(inst_id),
            )
        )
        .all()
    )
    return {
        "inst_id": uuid_to_str(res[0][0].id),
        "name": res[0][0].name,
        "state": res[0][0].state,
        "pdp_id": res[0][0].pdp_id,
        "retention_days": res[0][0].retention_days,
    }


@router.delete("/institutions/{inst_id}", response_model=None)
def delete_inst(
    inst_id: str,
    current_user: Annotated[BaseUser, Depends(get_current_active_user)],
    sql_session: Annotated[Session, Depends(get_session)],
    storage_control: Annotated[StorageControl, Depends(StorageControl)],
    databricks_control: Annotated[DatabricksControl, Depends(DatabricksControl)],
) -> Any:
    """Delete an existing institution.

    Only available to Datakinders.
    """
    if not current_user.is_datakinder():
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authorized to delete an institution.",
        )

    local_session.set(sql_session)
    query_result = (
        local_session.get()
        .execute(select(InstTable).where(InstTable.id == str_to_uuid(inst_id)))
        .all()
    )
    if len(query_result) != 1:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Unexpected number of institutions found. Expected 1 got "
            + str(len(query_result)),
        )
    inst_name = query_result[0][0].name
    local_session.get().execute(
        delete(InstTable).where(InstTable.id == str_to_uuid(inst_id))
    )
    local_session.get().commit()
    # Delete GCS bucket
    bucket_name = get_external_bucket_name(inst_id)
    try:
        storage_control.delete_bucket(bucket_name)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Storage bucket deletion failed:" + str(e),
        ) from e
    # Delete all databricks managed pieces.
    try:
        databricks_control.delete_inst(inst_name)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Databricks deletion failed:" + str(e),
        ) from e


# All other API transactions require the UUID as an identifier, this allows the UUID lookup by human readable name.
@router.get("/institutions/name/{inst_name}", response_model=Institution)
def read_inst_name(
    inst_name: str,
    current_user: Annotated[BaseUser, Depends(get_current_active_user)],
    sql_session: Annotated[Session, Depends(get_session)],
) -> Any:
    """Returns overview data on a specific institution.

    The root-level API view. Only visible to users of that institution or Datakinder access types.
    """
    local_session.set(sql_session)
    query_result = (
        local_session.get()
        .execute(select(InstTable).where(InstTable.name == inst_name))
        .all()
    )

    if len(query_result) == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Institution not found.",
        )
    if len(query_result) > 1:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Institution duplicates found.",
        )
    has_access_to_inst_or_err(uuid_to_str(query_result[0][0].id), current_user)
    return {
        "inst_id": uuid_to_str(query_result[0][0].id),
        "name": query_result[0][0].name,
        "retention_days": query_result[0][0].retention_days,
        "state": query_result[0][0].state,
        "pdp_id": query_result[0][0].pdp_id,
    }


# All other API transactions require the UUID as an identifier, this allows the UUID lookup by PDP ID.
@router.get("/institutions/pdp-id/{pdp_id}", response_model=Institution)
def read_inst_pdp_id(
    pdp_id: str,
    current_user: Annotated[BaseUser, Depends(get_current_active_user)],
    sql_session: Annotated[Session, Depends(get_session)],
) -> Any:
    """Returns the uuid for a school given its pdp_id. Endpoint allowed for any user."""
    local_session.set(sql_session)
    query_result = (
        local_session.get()
        .execute(select(InstTable).where(InstTable.pdp_id == pdp_id))
        .all()
    )
    if len(query_result) == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Institution not found.",
        )
    if len(query_result) > 1:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Institution duplicates found.",
        )
    has_access_to_inst_or_err(uuid_to_str(query_result[0][0].id), current_user)
    return {
        "inst_id": uuid_to_str(query_result[0][0].id),
        "name": query_result[0][0].name,
        "retention_days": query_result[0][0].retention_days,
        "state": query_result[0][0].state,
        "pdp_id": query_result[0][0].pdp_id,
    }


@router.get("/institutions/{inst_id}", response_model=Institution)
def read_inst_id(
    inst_id: str,
    current_user: Annotated[BaseUser, Depends(get_current_active_user)],
    sql_session: Annotated[Session, Depends(get_session)],
) -> Any:
    """Returns overview data on a specific institution.

    The root-level API view. Only visible to users of that institution or Datakinder access types.
    """
    has_access_to_inst_or_err(inst_id, current_user)
    local_session.set(sql_session)
    query_result = (
        local_session.get()
        .execute(select(InstTable).where(InstTable.id == str_to_uuid(inst_id)))
        .all()
    )
    if not query_result or len(query_result) == 0:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Institution not found.",
        )
    if len(query_result) > 1:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Institution duplicates found."
        )
    return {
        "inst_id": uuid_to_str(query_result[0][0].id),
        "name": query_result[0][0].name,
        "retention_days": query_result[0][0].retention_days,
        "state": query_result[0][0].state,
        "pdp_id": query_result[0][0].pdp_id,
    }
